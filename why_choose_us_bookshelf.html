<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Why Clients Choose Grope Hamilton Lawyers — Realistic 3D Bookshelf</title>
  <style>
    /* ====== 1. RESET & BASE STYLES ====== */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      background-color: #ffffff; /* white background */
      font-family: Arial, sans-serif;
      overflow: hidden;
    }
    canvas { display: block; } /* fill entire viewport */
    button {
      cursor: pointer;
      border: none;
      background: none;
      font-family: inherit;
    }

    /* ====== 2. MODAL & OPEN-BOOK STYLES ====== */
    .detail-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: rgba(0, 0, 0, 0.6);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .detail-overlay.show {
      display: flex;
    }
    .detail-book {
      position: relative;
      width: 90%;
      max-width: 500px;
      height: 300px;
      background: #ffffff;
      border-radius: 8px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
      overflow: hidden;
    }
    .detail-book::before {
      content: '';
      position: absolute;
      top: 0; left: 50%;
      width: 6px; height: 100%;
      background: #ef3125; /* brand red spine on detail */
      transform: translateX(-50%);
    }
    .detail-page-left,
    .detail-page-right {
      position: absolute;
      top: 20px; bottom: 20px;
      width: calc(50% - 16px);
      background: #ffffff;
      box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
      overflow-y: auto;
      padding: 16px;
      font-size: 1rem;
      color: #333333;
      line-height: 1.5;
    }
    .detail-page-left {
      left: 16px;
    }
    .detail-page-right {
      right: 16px;
    }
    .detail-close-btn {
      position: absolute;
      top: 12px; right: 12px;
      background-color: #ef3125;
      color: #ffffff;
      border: none;
      border-radius: 4px;
      padding: 6px 12px;
      font-size: 0.9rem;
      z-index: 2;
    }
    .detail-close-btn:hover {
      background-color: #d02a1f;
    }
  </style>
</head>
<body>

  <!-- ====== 1. Three.js Canvas ====== -->
  <canvas id="threejs-canvas"></canvas>

  <!-- ====== 2. Detail Overlays for Each Book ====== -->
  <div id="detail1" class="detail-overlay">
    <div class="detail-book">
      <button class="detail-close-btn">Close</button>
      <div class="detail-page-left">
        <h4 style="margin-top:0; color:#ef3125; font-weight: bold;">
          Trusted Experience
        </h4>
        <p>
          With over 42 years of continuous practice, we’ve earned the trust of generations of clients across a broad range of wills and estate matters. We are a proud Law Society of South Australia Gold Alliance Firm, recognized for our commitment to professionalism and ethical practice.
        </p>
      </div>
      <div class="detail-page-right"></div>
    </div>
  </div>

  <div id="detail2" class="detail-overlay">
    <div class="detail-book">
      <button class="detail-close-btn">Close</button>
      <div class="detail-page-left">
        <h4 style="margin-top:0; color:#ef3125; font-weight: bold;">
          Clear Advice
        </h4>
        <p>
          We provide advice that is both legally accurate and easy to understand. Clients come to us for guidance they can rely on, without jargon, and without assumptions.
        </p>
      </div>
      <div class="detail-page-right"></div>
    </div>
  </div>

  <div id="detail3" class="detail-overlay">
    <div class="detail-book">
      <button class="detail-close-btn">Close</button>
      <div class="detail-page-left">
        <h4 style="margin-top:0; color:#ef3125; font-weight: bold;">
          Personalized Approach
        </h4>
        <p>
          Every matter is different. We tailor our services to your circumstances, with a focus on achieving practical, legally sound results and minimizing the risk of future disputes.
        </p>
      </div>
      <div class="detail-page-right"></div>
    </div>
  </div>

  <div id="detail4" class="detail-overlay">
    <div class="detail-book">
      <button class="detail-close-btn">Close</button>
      <div class="detail-page-left">
        <h4 style="margin-top:0; color:#ef3125; font-weight: bold;">
          Respect &amp; Care
        </h4>
        <p>
          We recognize the sensitivity of estate planning. Clients are treated with courtesy, discretion, and genuine care throughout the process.
        </p>
      </div>
      <div class="detail-page-right"></div>
    </div>
  </div>

  <div id="detail5" class="detail-overlay">
    <div class="detail-book">
      <button class="detail-close-btn">Close</button>
      <div class="detail-page-left">
        <h4 style="margin-top:0; color:#ef3125; font-weight: bold;">
          Transparent Fees
        </h4>
        <p>
          We offer clear, upfront pricing with fixed‐fee options where appropriate. You’ll always know what to expect and why it matters.
        </p>
      </div>
      <div class="detail-page-right"></div>
    </div>
  </div>

  <div id="detail6" class="detail-overlay">
    <div class="detail-book">
      <button class="detail-close-btn">Close</button>
      <div class="detail-page-left">
        <h4 style="margin-top:0; color:#ef3125; font-weight: bold;">
          Multilingual Support
        </h4>
        <p>
          We offer multilingual support to assist clients from diverse cultural and linguistic backgrounds.
        </p>
      </div>
      <div class="detail-page-right"></div>
    </div>
  </div>

  <!-- ====== 3. Three.js + RoundedBoxGeometry & Interaction Logic ====== -->
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.132.2/examples/jsm/controls/OrbitControls.js';
    import { RoundedBoxGeometry } from 'https://cdn.jsdelivr.net/npm/three@0.132.2/examples/jsm/geometries/RoundedBoxGeometry.js';

    // --- A) SET UP SCENE, CAMERA, RENDERER ---
    const canvas = document.getElementById('threejs-canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0xffffff, 1); // white background

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 6, 14);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enablePan = false;
    controls.enableZoom = true;
    controls.minDistance = 8;
    controls.maxDistance = 25;
    controls.target.set(0, 4, 0);

    // --- B) LIGHTING ---
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
    hemiLight.position.set(0, 20, 0);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5, 10, 7);
    dirLight.castShadow = true;
    scene.add(dirLight);

    // --- C) LOAD WOOD TEXTURE FOR SHELVES ---
    const woodTextureURL = 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/floor/wood.jpg';
    const woodTexture = new THREE.TextureLoader().load(woodTextureURL);
    woodTexture.wrapS = woodTexture.wrapT = THREE.RepeatWrapping;
    woodTexture.repeat.set(4, 1);

    // --- D) CREATE 3 LAYERS OF TEXTURED SHELVES ---
    const shelfMaterial = new THREE.MeshStandardMaterial({ map: woodTexture });
    const shelfGeo = new THREE.BoxGeometry(12, 0.3, 2);

    // Bottom shelf at y = 1
    const shelf1 = new THREE.Mesh(shelfGeo, shelfMaterial);
    shelf1.position.set(0, 1, 0);
    shelf1.receiveShadow = true;
    scene.add(shelf1);

    // Middle shelf at y = 4
    const shelf2 = new THREE.Mesh(shelfGeo, shelfMaterial);
    shelf2.position.set(0, 4, 0);
    shelf2.receiveShadow = true;
    scene.add(shelf2);

    // Top shelf at y = 7
    const shelf3 = new THREE.Mesh(shelfGeo, shelfMaterial);
    shelf3.position.set(0, 7, 0);
    shelf3.receiveShadow = true;
    scene.add(shelf3);

    // Backboard behind all shelves
    const backboardGeo = new THREE.BoxGeometry(12, 10, 0.3);
    const backboardMat = new THREE.MeshStandardMaterial({ color: 0xf2f2f2 });
    const backboard = new THREE.Mesh(backboardGeo, backboardMat);
    backboard.position.set(0, 5, -1.15);
    backboard.receiveShadow = true;
    scene.add(backboard);

    // --- E) BOOK DATA & CREATION ---
    const booksInfo = [
      { id: 'detail1', label: 'Trusted Experience' },
      { id: 'detail2', label: 'Clear Advice' },
      { id: 'detail3', label: 'Personalized Approach' },
      { id: 'detail4', label: 'Respect & Care' },
      { id: 'detail5', label: 'Transparent Fees' },
      { id: 'detail6', label: 'Multilingual Support' }
    ];

    // Create a CanvasTexture for each book spine with big white bold text:
    function createSpineTexture(text) {
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');

      // Fill red (#ef3125)
      ctx.fillStyle = '#ef3125';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw white, large, bold, vertical text in the center
      ctx.fillStyle = '#FFFFFF';
      ctx.font = 'bold 32px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      ctx.save();
      ctx.translate(canvas.width / 2, canvas.height / 2);
      ctx.rotate(Math.PI / 2); // 90° so the text reads bottom→top
      ctx.fillText(text, 0, 0);
      ctx.restore();

      return new THREE.CanvasTexture(canvas);
    }

    const bookMeshes = [];

    // We’ll place 2 books on each shelf (positions X = -3, +3), Y just above shelf
    const shelfYPositions = [1.6, 4.6, 7.6];
    const positionsX = [-3, 3];

    booksInfo.forEach((info, idx) => {
      const shelfIndex = Math.floor(idx / 2);   // 0..2
      const posIndex = idx % 2;                 // 0 or 1
      const x = positionsX[posIndex];
      const y = shelfYPositions[shelfIndex];
      const z = 0;

      // Use RoundedBoxGeometry for a more realistic “rounded spine”:
      const bookGeo = new RoundedBoxGeometry(0.6, 2.5, 1.2, 8, 0.05);

      // Create materials: +X face = spine with text, others = solid red
      const spineTex = createSpineTexture(info.label);
      const mats = [
        new THREE.MeshStandardMaterial({ map: spineTex }),  // +X (spine)
        new THREE.MeshStandardMaterial({ color: 0xef3125 }), // -X (back face)
        new THREE.MeshStandardMaterial({ color: 0xef3125 }), // +Y (top)
        new THREE.MeshStandardMaterial({ color: 0xef3125 }), // -Y (bottom)
        new THREE.MeshStandardMaterial({ color: 0xef3125 }), // +Z (front cover)
        new THREE.MeshStandardMaterial({ color: 0xef3125 })  // -Z (back cover)
      ];

      const mesh = new THREE.Mesh(bookGeo, mats);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.position.set(x, y, z);

      // Save original transform for “push-back”
      mesh.userData = {
        modalId: info.id,
        originalPosition: mesh.position.clone(),
        originalQuaternion: mesh.quaternion.clone(),
        pulled: false
      };

      scene.add(mesh);
      bookMeshes.push(mesh);
    });

    // --- F) RAYCASTER & “PULL OUT” LOGIC ---
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function onPointerDown(event) {
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(bookMeshes);
      if (intersects.length > 0) {
        const clicked = intersects[0].object;
        toggleBookPull(clicked);
      }
    }
    window.addEventListener('pointerdown', onPointerDown);

    function toggleBookPull(book) {
      bookMeshes.forEach(b => {
        if (b === book) {
          if (!b.userData.pulled) {
            // Pull out along negative Z by -1.5 units and tilt by -45° on Y
            b.userData.pulled = true;
            const targetPos = b.userData.originalPosition.clone().add(new THREE.Vector3(0, 0, -1.5));
            b.userData.targetPosition = targetPos;
            const targetQuat = new THREE.Quaternion().setFromEuler(
              new THREE.Euler(0, -Math.PI / 4, 0)
            );
            b.userData.targetQuaternion = targetQuat;
            // Show the detail overlay
            document.getElementById(b.userData.modalId).classList.add('show');
          } else {
            // Push back to shelf
            b.userData.pulled = false;
            b.userData.targetPosition = b.userData.originalPosition.clone();
            b.userData.targetQuaternion = b.userData.originalQuaternion.clone();
            document.getElementById(b.userData.modalId).classList.remove('show');
          }
        } else {
          // Immediately reset all other books
          b.userData.pulled = false;
          b.userData.targetPosition = b.userData.originalPosition.clone();
          b.userData.targetQuaternion = b.userData.originalQuaternion.clone();
          document.getElementById(b.userData.modalId).classList.remove('show');
        }
      });
    }

    // --- G) ANIMATION & RENDER LOOP ---
    function animate() {
      requestAnimationFrame(animate);
      const lerpFactor = 0.1;
      bookMeshes.forEach(b => {
        if (b.userData.targetPosition) {
          b.position.lerp(b.userData.targetPosition, lerpFactor);
        }
        if (b.userData.targetQuaternion) {
          b.quaternion.slerp(b.userData.targetQuaternion, lerpFactor);
        }
      });
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      const w = window.innerWidth, h = window.innerHeight;
      renderer.setSize(w, h);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    });

    // --- H) MODAL CLOSE HANDLERS ---
    document.querySelectorAll('.detail-close-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const overlay = btn.closest('.detail-overlay');
        overlay.classList.remove('show');
        const modalId = overlay.id;
        const book = bookMeshes.find(b => b.userData.modalId === modalId);
        if (book) {
          book.userData.pulled = false;
          book.userData.targetPosition = book.userData.originalPosition.clone();
          book.userData.targetQuaternion = book.userData.originalQuaternion.clone();
        }
      });
    });

    document.querySelectorAll('.detail-overlay').forEach(over => {
      over.addEventListener('click', (e) => {
        if (e.target === over) {
          over.classList.remove('show');
          const modalId = over.id;
          const book = bookMeshes.find(b => b.userData.modalId === modalId);
          if (book) {
            book.userData.pulled = false;
            book.userData.targetPosition = book.userData.originalPosition.clone();
            book.userData.targetQuaternion = book.userData.originalQuaternion.clone();
          }
        }
      });
    });
  </script>
</body>
</html>